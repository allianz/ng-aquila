<p class="docs-markdown--p">This component is implemented on top of the native HTML table <code>&lt;table&gt;&lt;/table&gt;</code> and adds the needed styling. In addition, there is an expandable table option for advanced use cases.</p>
<p class="docs-markdown--p">We provide the following directives: <code>nxTableCell</code>, <code>nxTableRow</code> and <code>nxHeaderCell</code> to apply our style respectively on the top of <code>td</code>, <code>tr</code> and <code>th</code>. This setup maintains the capabilities of the native table such as accessibility and native HTML markups within cells.</p>
<p class="docs-markdown--p">According to our UX guidelines we recommend wrapping your tables in a horizontal scrolling container (if they are not 100% responsive). Please note how our examples do that.</p>
<div nx-docs-example="table" config="{}">exampleID: table</div>
<h3 id="condensed-mode" tabindex="-1" class="docs-markdown--h3">Condensed mode</h3>
<p class="docs-markdown--p">By using attribute <code>condensed</code>, you can activate the condensed mode of the Table.</p>
<div nx-docs-example="table-condensed" config="{}">exampleID: table-condensed</div>
<h3 id="zebra-mode" tabindex="-1" class="docs-markdown--h3">Zebra mode</h3>
<p class="docs-markdown--p">Using attribute <code>zebra</code>, you can activate the zebra mode of the Table.</p>
<div nx-docs-example="table-zebra" config="{}">exampleID: table-zebra</div>
<h3 id="sticky-columns" tabindex="-1" class="docs-markdown--h3">Sticky columns</h3>
<p class="docs-markdown--p">Using attribute <code>sticky</code>, you can make first or last column (or both of them at the same time) of the table be displayed as &quot;sticky&quot;, by setting its value to <code>first</code>, <code>last</code> or <code>both</code> respectively.</p>
<p class="docs-markdown--p">Please note that you are only allowed to make the first and/or last column sticky, to prohibit covering too much screen estate by fixed columns. For the same reason, this setting won't have effect on mobile screens.</p>
<div nx-docs-example="table-sticky-column" config="{}">exampleID: table-sticky-column</div>
<h3 id="sticky-header" tabindex="-1" class="docs-markdown--h3">Sticky header</h3>
<p class="docs-markdown--p">For a simple &quot;sticky&quot; header you can use the attribute <code>mayStick</code> on the <code>nxTableRow</code> element.</p>
<p class="docs-markdown--p">For more complex use-cases, please consider either coming up with a custom CSS/Typescript solution or using a third-party datatable library.</p>
<div nx-docs-example="table-sticky-header" config="{}">exampleID: table-sticky-header</div>
<h3 id="column-hiding-and-reorder-columns" tabindex="-1" class="docs-markdown--h3">Column hiding and reorder columns</h3>
<p class="docs-markdown--p">Application developers can implement custom column behavior, such as column hiding and reorder columns.</p>
<div nx-docs-example="table-column-hiding" config="{}">exampleID: table-column-hiding</div>
<h3 id="column-reorder-with-drag-%26-drop" tabindex="-1" class="docs-markdown--h3">Column reorder with drag &amp; drop</h3>
<p class="docs-markdown--p">To allow users to reorder columns by drag and drop, you can use <a href="https://material.angular.io/cdk/drag-drop">CDKdrag</a> from the Angular Material CDK library. To get started, you need to import <code>DragDropModule</code> from <code>@angular/cdk/drag-drop</code> and add the cdkDrag directive. Here's a simple example:</p>
<div class="docs-deprecation-warning">
  <strong>Note:</strong> This is a technical demo for column reordering and is not a fully supported component. Additional implementation is required to ensure proper accessibility, UX, and design before using it in production.
</div>
 <div nx-docs-example="table-column-reorder" config="{}">exampleID: table-column-reorder</div>
<h3 id="localization" tabindex="-1" class="docs-markdown--h3">Localization</h3>
<p class="docs-markdown--p">For <strong>localization</strong> please use the provider <code>NxHeaderSortIntl</code> which contains some labels for screen reader users. By default the labels are in english.</p>
<pre><code class="language-ts"><span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIntl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">NxSortHeaderIntl</span> {
    sortAscendingAriaLabel = <span class="hljs-string">&#x27;klick, um aufsteigend zu sortieren&#x27;</span>;
    sortDescendingAriaLabel = <span class="hljs-string">&#x27;klick, um absteigend zu sortieren&#x27;</span>;
    sortedAscendingAriaLabel = <span class="hljs-string">&#x27;aufsteigend sortiert nach&#x27;</span>;
    sortedDescendingAriaLabel = <span class="hljs-string">&#x27;absteigend sortiert nach&#x27;</span>;
}

<span class="hljs-meta">@Component</span>({
    ...
    <span class="hljs-attr">providers</span>: [
        { 
            <span class="hljs-attr">provide</span>: <span class="hljs-title class_">NxSortHeaderIntl</span>, 
            <span class="hljs-attr">useClass</span>: <span class="hljs-title class_">MyIntl</span> 
        }
    ],
})
</code></pre>
<h3 id="sorting-header" tabindex="-1" class="docs-markdown--h3">Sorting header</h3>
<p class="docs-markdown--p">This example shows how you can implement a basic sorting functionality for a table with <code>nxSort</code> and <code>nxSortHeaderCell</code>. As we don't know how your data looks like, you can implement the actual sorting function by yourself and call the function every time an <code>(sortChange)</code> event is outputted.</p>
<div nx-docs-example="table-sorting" config="{}">exampleID: table-sorting</div>
<h3 id="advanced-example%3A-combine-sorting%2C-filtering-and-pagination" tabindex="-1" class="docs-markdown--h3">Advanced example: Combine sorting, filtering and pagination</h3>
<p class="docs-markdown--p">By using the <code>nx-pagination</code> and <code>nx-formfield</code> you can filter and paginate the table items as shown in the example below:</p>
<div nx-docs-example="table-filter-sort-paginate" config="{}">exampleID: table-filter-sort-paginate</div>
<h3 id="selecting-rows" tabindex="-1" class="docs-markdown--h3">Selecting rows</h3>
<p class="docs-markdown--p">The following example shows how you can implement a selection functionality with the <code>SelectionModel</code> of Angular CDK. To show the selected values, you can toggle 'Debug selected value' under the table. To be able to interact and select a table row, the <code>selectable</code> option needs to be set on the <code>NxTableRow</code>.</p>
<div nx-docs-example="table-single-select" config="{}">exampleID: table-single-select</div>
<p class="docs-markdown--p">Multi selection can be implemented by switching on the multi select flag on the <code>SelectionModel</code>.</p>
<p class="docs-markdown--p">Note that you can separate the data selection logic from row highlighting, for example if click on the row has to trigger a popup, sidebar expansion, etc.</p>
<div nx-docs-example="table-selecting" config="{}">exampleID: table-selecting</div>
<div class="docs-expert-container">
<h3 id="expert%3A-expandable-mode" tabindex="-1" class="docs-markdown--h3">Expert: Expandable mode</h3>
<p class="docs-markdown--p">Please note that <strong>this is an Expert styling option</strong>. This means that the expandable feature is only intended for internal applications and not for applications that are client facing.</p>
<p class="docs-markdown--p">Table rows can be expanded by adding <code>[nxExpandableTableRow]</code> and <code>[nxExpandableTableCell]</code> to the table. For convenience the <code>&lt;nx-toggle-button&gt;</code> component can be used to expand and close the rows. The rows can also be toggled directly by calling their <code>toggle</code>, <code>expand</code> or <code>close</code> methods. The table also supports expanding all rows at the same time. The <code>[nxExpandableTable]</code> and <code>ng-container[nxExpandableContainer]</code> directive handles the expandion of all rows by conbining it with the <code>&lt;nx-toggle-button&gt;</code> as in this example.</p>
<p class="docs-markdown--p"><strong>Due to accessibility concerns</strong> we recommend only placing table content inside <code>nxExpandableTableRow</code>. If you need to insert complex content into an expandable row or have table-in-table treeview, consider using third-party Datatable solutions.</p>
<p class="docs-markdown--p"><strong>Note:</strong> For accessibility, ensure that columns in the Table contain consistent content. Expandable rows should maintain the same content structure as defined by the column headers.</p>
<p class="docs-markdown--p">However, zebra mode using the attribute <code>zebra</code> is not available for tables with expandable rows for stylistic reasons.</p>
<div nx-docs-example="table-expandable" config="{}">exampleID: table-expandable</div>
<h3 id="expert%3A-expandable-table-with-indentation" tabindex="-1" class="docs-markdown--h3">Expert: Expandable table with indentation</h3>
<p class="docs-markdown--p">You can add indentation to an expandable cell inside an expandable row to make it distinct from firstâ€‘level rows by adding the <code>[indented]</code> property alongside the proper <code>[nxExpandableTableCell]</code> directive.</p>
<div nx-docs-example="table-expandable-indent" config="{}">exampleID: table-expandable-indent</div>
<h3 id="expert%3A-form-elements" tabindex="-1" class="docs-markdown--h3">Expert: Form elements</h3>
<p class="docs-markdown--p">Form elements can also be added to the table:</p>
<div nx-docs-example="table-form-elements" config="{}">exampleID: table-form-elements</div>
</div>
<h3 id="accessibility" tabindex="-1" class="docs-markdown--h3">Accessibility</h3>
<p class="docs-markdown--p">Content should not be clipped, find more info on the <a href="https://www.w3.org/WAI/WCAG21/Understanding/reflow.html">WCAG criteria</a>. If clipping/cropping is strictly required it can be done via custom css. In that case it's necessary to make the full content accessible through other means. Align with your accessibility expert if clipping of content is required.</p>
<p class="docs-markdown--p">It is essential for users that column labels are fully visible, even when the text is enlarged. Therefore, it is important to ensure meaningful naming and sufficient column width during the design and implementation phases.</p>
<div class="docs-private">
  To reduce complexity, the option to adjust column widths via the keyboard has been omitted. For very complex and extensive table layouts, the use of a data grid is recommended, as this allows all users to adjust column widths via the keyboard. We recommend using AG Grid. 
</div> 